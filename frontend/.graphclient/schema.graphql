schema {
  query: Query
  subscription: Subscription
}

"""
Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive.
"""
directive @entity on OBJECT

"""Defined a Subgraph ID for an object type"""
directive @subgraphId(id: String!) on OBJECT

"""
creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API.
"""
directive @derivedFrom(field: String!) on FIELD_DEFINITION

enum Aggregation_interval {
  hour
  day
}

scalar BigDecimal

scalar BigInt

input BlockChangedFilter {
  number_gte: Int!
}

input Block_height {
  hash: Bytes
  number: Int
  number_gte: Int
}

scalar Bytes

type CityIndex {
  id: ID!
  owner: Bytes!
  name: String!
  code: String!
  symbol: String!
  squareFeet: BigInt!
  createdAtBlock: BigInt!
  createdAtTimestamp: BigInt!
  codeUpdates(skip: Int = 0, first: Int = 100, orderBy: CodeUpdate_orderBy, orderDirection: OrderDirection, where: CodeUpdate_filter): [CodeUpdate!]!
  priceFeedRequests(skip: Int = 0, first: Int = 100, orderBy: PriceFeedRequest_orderBy, orderDirection: OrderDirection, where: PriceFeedRequest_filter): [PriceFeedRequest!]!
  tokenBuys(skip: Int = 0, first: Int = 100, orderBy: TokenBuy_orderBy, orderDirection: OrderDirection, where: TokenBuy_filter): [TokenBuy!]!
  tokenSells(skip: Int = 0, first: Int = 100, orderBy: TokenSell_orderBy, orderDirection: OrderDirection, where: TokenSell_filter): [TokenSell!]!
}

type CityIndexCreated {
  id: ID!
  owner: Bytes!
  cityIndexAddress: Bytes!
  name: String!
  code: String!
  symbol: String!
  squareFeet: BigInt!
  blockNumber: BigInt!
  timestamp: BigInt!
}

input CityIndexCreated_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  owner: Bytes
  owner_not: Bytes
  owner_gt: Bytes
  owner_lt: Bytes
  owner_gte: Bytes
  owner_lte: Bytes
  owner_in: [Bytes!]
  owner_not_in: [Bytes!]
  owner_contains: Bytes
  owner_not_contains: Bytes
  cityIndexAddress: Bytes
  cityIndexAddress_not: Bytes
  cityIndexAddress_gt: Bytes
  cityIndexAddress_lt: Bytes
  cityIndexAddress_gte: Bytes
  cityIndexAddress_lte: Bytes
  cityIndexAddress_in: [Bytes!]
  cityIndexAddress_not_in: [Bytes!]
  cityIndexAddress_contains: Bytes
  cityIndexAddress_not_contains: Bytes
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  code: String
  code_not: String
  code_gt: String
  code_lt: String
  code_gte: String
  code_lte: String
  code_in: [String!]
  code_not_in: [String!]
  code_contains: String
  code_contains_nocase: String
  code_not_contains: String
  code_not_contains_nocase: String
  code_starts_with: String
  code_starts_with_nocase: String
  code_not_starts_with: String
  code_not_starts_with_nocase: String
  code_ends_with: String
  code_ends_with_nocase: String
  code_not_ends_with: String
  code_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  squareFeet: BigInt
  squareFeet_not: BigInt
  squareFeet_gt: BigInt
  squareFeet_lt: BigInt
  squareFeet_gte: BigInt
  squareFeet_lte: BigInt
  squareFeet_in: [BigInt!]
  squareFeet_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [CityIndexCreated_filter]
  or: [CityIndexCreated_filter]
}

enum CityIndexCreated_orderBy {
  id
  owner
  cityIndexAddress
  name
  code
  symbol
  squareFeet
  blockNumber
  timestamp
}

type CityIndexFactory {
  id: ID!
  cityIndexes(skip: Int = 0, first: Int = 100, orderBy: CityIndex_orderBy, orderDirection: OrderDirection, where: CityIndex_filter): [CityIndex!]!
}

input CityIndexFactory_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  cityIndexes: [String!]
  cityIndexes_not: [String!]
  cityIndexes_contains: [String!]
  cityIndexes_contains_nocase: [String!]
  cityIndexes_not_contains: [String!]
  cityIndexes_not_contains_nocase: [String!]
  cityIndexes_: CityIndex_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [CityIndexFactory_filter]
  or: [CityIndexFactory_filter]
}

enum CityIndexFactory_orderBy {
  id
  cityIndexes
}

input CityIndex_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  owner: Bytes
  owner_not: Bytes
  owner_gt: Bytes
  owner_lt: Bytes
  owner_gte: Bytes
  owner_lte: Bytes
  owner_in: [Bytes!]
  owner_not_in: [Bytes!]
  owner_contains: Bytes
  owner_not_contains: Bytes
  name: String
  name_not: String
  name_gt: String
  name_lt: String
  name_gte: String
  name_lte: String
  name_in: [String!]
  name_not_in: [String!]
  name_contains: String
  name_contains_nocase: String
  name_not_contains: String
  name_not_contains_nocase: String
  name_starts_with: String
  name_starts_with_nocase: String
  name_not_starts_with: String
  name_not_starts_with_nocase: String
  name_ends_with: String
  name_ends_with_nocase: String
  name_not_ends_with: String
  name_not_ends_with_nocase: String
  code: String
  code_not: String
  code_gt: String
  code_lt: String
  code_gte: String
  code_lte: String
  code_in: [String!]
  code_not_in: [String!]
  code_contains: String
  code_contains_nocase: String
  code_not_contains: String
  code_not_contains_nocase: String
  code_starts_with: String
  code_starts_with_nocase: String
  code_not_starts_with: String
  code_not_starts_with_nocase: String
  code_ends_with: String
  code_ends_with_nocase: String
  code_not_ends_with: String
  code_not_ends_with_nocase: String
  symbol: String
  symbol_not: String
  symbol_gt: String
  symbol_lt: String
  symbol_gte: String
  symbol_lte: String
  symbol_in: [String!]
  symbol_not_in: [String!]
  symbol_contains: String
  symbol_contains_nocase: String
  symbol_not_contains: String
  symbol_not_contains_nocase: String
  symbol_starts_with: String
  symbol_starts_with_nocase: String
  symbol_not_starts_with: String
  symbol_not_starts_with_nocase: String
  symbol_ends_with: String
  symbol_ends_with_nocase: String
  symbol_not_ends_with: String
  symbol_not_ends_with_nocase: String
  squareFeet: BigInt
  squareFeet_not: BigInt
  squareFeet_gt: BigInt
  squareFeet_lt: BigInt
  squareFeet_gte: BigInt
  squareFeet_lte: BigInt
  squareFeet_in: [BigInt!]
  squareFeet_not_in: [BigInt!]
  createdAtBlock: BigInt
  createdAtBlock_not: BigInt
  createdAtBlock_gt: BigInt
  createdAtBlock_lt: BigInt
  createdAtBlock_gte: BigInt
  createdAtBlock_lte: BigInt
  createdAtBlock_in: [BigInt!]
  createdAtBlock_not_in: [BigInt!]
  createdAtTimestamp: BigInt
  createdAtTimestamp_not: BigInt
  createdAtTimestamp_gt: BigInt
  createdAtTimestamp_lt: BigInt
  createdAtTimestamp_gte: BigInt
  createdAtTimestamp_lte: BigInt
  createdAtTimestamp_in: [BigInt!]
  createdAtTimestamp_not_in: [BigInt!]
  codeUpdates: [String!]
  codeUpdates_not: [String!]
  codeUpdates_contains: [String!]
  codeUpdates_contains_nocase: [String!]
  codeUpdates_not_contains: [String!]
  codeUpdates_not_contains_nocase: [String!]
  codeUpdates_: CodeUpdate_filter
  priceFeedRequests: [String!]
  priceFeedRequests_not: [String!]
  priceFeedRequests_contains: [String!]
  priceFeedRequests_contains_nocase: [String!]
  priceFeedRequests_not_contains: [String!]
  priceFeedRequests_not_contains_nocase: [String!]
  priceFeedRequests_: PriceFeedRequest_filter
  tokenBuys: [String!]
  tokenBuys_not: [String!]
  tokenBuys_contains: [String!]
  tokenBuys_contains_nocase: [String!]
  tokenBuys_not_contains: [String!]
  tokenBuys_not_contains_nocase: [String!]
  tokenBuys_: TokenBuy_filter
  tokenSells: [String!]
  tokenSells_not: [String!]
  tokenSells_contains: [String!]
  tokenSells_contains_nocase: [String!]
  tokenSells_not_contains: [String!]
  tokenSells_not_contains_nocase: [String!]
  tokenSells_: TokenSell_filter
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [CityIndex_filter]
  or: [CityIndex_filter]
}

enum CityIndex_orderBy {
  id
  owner
  name
  code
  symbol
  squareFeet
  createdAtBlock
  createdAtTimestamp
  codeUpdates
  priceFeedRequests
  tokenBuys
  tokenSells
}

type CodeUpdate {
  id: ID!
  cityIndex: CityIndex!
  oldCode: String!
  newCode: String!
  blockNumber: BigInt!
  timestamp: BigInt!
}

input CodeUpdate_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  cityIndex: String
  cityIndex_not: String
  cityIndex_gt: String
  cityIndex_lt: String
  cityIndex_gte: String
  cityIndex_lte: String
  cityIndex_in: [String!]
  cityIndex_not_in: [String!]
  cityIndex_contains: String
  cityIndex_contains_nocase: String
  cityIndex_not_contains: String
  cityIndex_not_contains_nocase: String
  cityIndex_starts_with: String
  cityIndex_starts_with_nocase: String
  cityIndex_not_starts_with: String
  cityIndex_not_starts_with_nocase: String
  cityIndex_ends_with: String
  cityIndex_ends_with_nocase: String
  cityIndex_not_ends_with: String
  cityIndex_not_ends_with_nocase: String
  cityIndex_: CityIndex_filter
  oldCode: String
  oldCode_not: String
  oldCode_gt: String
  oldCode_lt: String
  oldCode_gte: String
  oldCode_lte: String
  oldCode_in: [String!]
  oldCode_not_in: [String!]
  oldCode_contains: String
  oldCode_contains_nocase: String
  oldCode_not_contains: String
  oldCode_not_contains_nocase: String
  oldCode_starts_with: String
  oldCode_starts_with_nocase: String
  oldCode_not_starts_with: String
  oldCode_not_starts_with_nocase: String
  oldCode_ends_with: String
  oldCode_ends_with_nocase: String
  oldCode_not_ends_with: String
  oldCode_not_ends_with_nocase: String
  newCode: String
  newCode_not: String
  newCode_gt: String
  newCode_lt: String
  newCode_gte: String
  newCode_lte: String
  newCode_in: [String!]
  newCode_not_in: [String!]
  newCode_contains: String
  newCode_contains_nocase: String
  newCode_not_contains: String
  newCode_not_contains_nocase: String
  newCode_starts_with: String
  newCode_starts_with_nocase: String
  newCode_not_starts_with: String
  newCode_not_starts_with_nocase: String
  newCode_ends_with: String
  newCode_ends_with_nocase: String
  newCode_not_ends_with: String
  newCode_not_ends_with_nocase: String
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [CodeUpdate_filter]
  or: [CodeUpdate_filter]
}

enum CodeUpdate_orderBy {
  id
  cityIndex
  cityIndex__id
  cityIndex__owner
  cityIndex__name
  cityIndex__code
  cityIndex__symbol
  cityIndex__squareFeet
  cityIndex__createdAtBlock
  cityIndex__createdAtTimestamp
  oldCode
  newCode
  blockNumber
  timestamp
}

"""
8 bytes signed integer

"""
scalar Int8

"""Defines the order direction, either ascending or descending"""
enum OrderDirection {
  asc
  desc
}

type PriceFeedRequest {
  id: ID!
  cityIndex: CityIndex!
  subscriptionId: BigInt!
  requestId: Bytes!
  blockNumber: BigInt!
  timestamp: BigInt!
}

input PriceFeedRequest_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  cityIndex: String
  cityIndex_not: String
  cityIndex_gt: String
  cityIndex_lt: String
  cityIndex_gte: String
  cityIndex_lte: String
  cityIndex_in: [String!]
  cityIndex_not_in: [String!]
  cityIndex_contains: String
  cityIndex_contains_nocase: String
  cityIndex_not_contains: String
  cityIndex_not_contains_nocase: String
  cityIndex_starts_with: String
  cityIndex_starts_with_nocase: String
  cityIndex_not_starts_with: String
  cityIndex_not_starts_with_nocase: String
  cityIndex_ends_with: String
  cityIndex_ends_with_nocase: String
  cityIndex_not_ends_with: String
  cityIndex_not_ends_with_nocase: String
  cityIndex_: CityIndex_filter
  subscriptionId: BigInt
  subscriptionId_not: BigInt
  subscriptionId_gt: BigInt
  subscriptionId_lt: BigInt
  subscriptionId_gte: BigInt
  subscriptionId_lte: BigInt
  subscriptionId_in: [BigInt!]
  subscriptionId_not_in: [BigInt!]
  requestId: Bytes
  requestId_not: Bytes
  requestId_gt: Bytes
  requestId_lt: Bytes
  requestId_gte: Bytes
  requestId_lte: Bytes
  requestId_in: [Bytes!]
  requestId_not_in: [Bytes!]
  requestId_contains: Bytes
  requestId_not_contains: Bytes
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [PriceFeedRequest_filter]
  or: [PriceFeedRequest_filter]
}

enum PriceFeedRequest_orderBy {
  id
  cityIndex
  cityIndex__id
  cityIndex__owner
  cityIndex__name
  cityIndex__code
  cityIndex__symbol
  cityIndex__squareFeet
  cityIndex__createdAtBlock
  cityIndex__createdAtTimestamp
  subscriptionId
  requestId
  blockNumber
  timestamp
}

type Query {
  cityIndexFactory(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CityIndexFactory
  cityIndexFactories(
    skip: Int = 0
    first: Int = 100
    orderBy: CityIndexFactory_orderBy
    orderDirection: OrderDirection
    where: CityIndexFactory_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CityIndexFactory!]!
  cityIndex(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CityIndex
  cityIndexes(
    skip: Int = 0
    first: Int = 100
    orderBy: CityIndex_orderBy
    orderDirection: OrderDirection
    where: CityIndex_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CityIndex!]!
  codeUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CodeUpdate
  codeUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: CodeUpdate_orderBy
    orderDirection: OrderDirection
    where: CodeUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CodeUpdate!]!
  priceFeedRequest(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PriceFeedRequest
  priceFeedRequests(
    skip: Int = 0
    first: Int = 100
    orderBy: PriceFeedRequest_orderBy
    orderDirection: OrderDirection
    where: PriceFeedRequest_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PriceFeedRequest!]!
  tokenBuy(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenBuy
  tokenBuys(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenBuy_orderBy
    orderDirection: OrderDirection
    where: TokenBuy_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenBuy!]!
  tokenSell(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenSell
  tokenSells(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenSell_orderBy
    orderDirection: OrderDirection
    where: TokenSell_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenSell!]!
  cityIndexCreated(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CityIndexCreated
  cityIndexCreateds(
    skip: Int = 0
    first: Int = 100
    orderBy: CityIndexCreated_orderBy
    orderDirection: OrderDirection
    where: CityIndexCreated_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CityIndexCreated!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

type Subscription {
  cityIndexFactory(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CityIndexFactory
  cityIndexFactories(
    skip: Int = 0
    first: Int = 100
    orderBy: CityIndexFactory_orderBy
    orderDirection: OrderDirection
    where: CityIndexFactory_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CityIndexFactory!]!
  cityIndex(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CityIndex
  cityIndexes(
    skip: Int = 0
    first: Int = 100
    orderBy: CityIndex_orderBy
    orderDirection: OrderDirection
    where: CityIndex_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CityIndex!]!
  codeUpdate(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CodeUpdate
  codeUpdates(
    skip: Int = 0
    first: Int = 100
    orderBy: CodeUpdate_orderBy
    orderDirection: OrderDirection
    where: CodeUpdate_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CodeUpdate!]!
  priceFeedRequest(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): PriceFeedRequest
  priceFeedRequests(
    skip: Int = 0
    first: Int = 100
    orderBy: PriceFeedRequest_orderBy
    orderDirection: OrderDirection
    where: PriceFeedRequest_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [PriceFeedRequest!]!
  tokenBuy(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenBuy
  tokenBuys(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenBuy_orderBy
    orderDirection: OrderDirection
    where: TokenBuy_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenBuy!]!
  tokenSell(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): TokenSell
  tokenSells(
    skip: Int = 0
    first: Int = 100
    orderBy: TokenSell_orderBy
    orderDirection: OrderDirection
    where: TokenSell_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [TokenSell!]!
  cityIndexCreated(
    id: ID!
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): CityIndexCreated
  cityIndexCreateds(
    skip: Int = 0
    first: Int = 100
    orderBy: CityIndexCreated_orderBy
    orderDirection: OrderDirection
    where: CityIndexCreated_filter
    """
    The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted.
    """
    block: Block_height
    """
    Set to `allow` to receive data even if the subgraph has skipped over errors while syncing.
    """
    subgraphError: _SubgraphErrorPolicy_! = deny
  ): [CityIndexCreated!]!
  """Access to subgraph metadata"""
  _meta(block: Block_height): _Meta_
}

"""
A string representation of microseconds UNIX timestamp (16 digits)

"""
scalar Timestamp

type TokenBuy {
  id: ID!
  cityIndex: CityIndex!
  buyer: Bytes!
  amount: BigInt!
  blockNumber: BigInt!
  timestamp: BigInt!
}

input TokenBuy_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  cityIndex: String
  cityIndex_not: String
  cityIndex_gt: String
  cityIndex_lt: String
  cityIndex_gte: String
  cityIndex_lte: String
  cityIndex_in: [String!]
  cityIndex_not_in: [String!]
  cityIndex_contains: String
  cityIndex_contains_nocase: String
  cityIndex_not_contains: String
  cityIndex_not_contains_nocase: String
  cityIndex_starts_with: String
  cityIndex_starts_with_nocase: String
  cityIndex_not_starts_with: String
  cityIndex_not_starts_with_nocase: String
  cityIndex_ends_with: String
  cityIndex_ends_with_nocase: String
  cityIndex_not_ends_with: String
  cityIndex_not_ends_with_nocase: String
  cityIndex_: CityIndex_filter
  buyer: Bytes
  buyer_not: Bytes
  buyer_gt: Bytes
  buyer_lt: Bytes
  buyer_gte: Bytes
  buyer_lte: Bytes
  buyer_in: [Bytes!]
  buyer_not_in: [Bytes!]
  buyer_contains: Bytes
  buyer_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TokenBuy_filter]
  or: [TokenBuy_filter]
}

enum TokenBuy_orderBy {
  id
  cityIndex
  cityIndex__id
  cityIndex__owner
  cityIndex__name
  cityIndex__code
  cityIndex__symbol
  cityIndex__squareFeet
  cityIndex__createdAtBlock
  cityIndex__createdAtTimestamp
  buyer
  amount
  blockNumber
  timestamp
}

type TokenSell {
  id: ID!
  cityIndex: CityIndex!
  seller: Bytes!
  amount: BigInt!
  blockNumber: BigInt!
  timestamp: BigInt!
}

input TokenSell_filter {
  id: ID
  id_not: ID
  id_gt: ID
  id_lt: ID
  id_gte: ID
  id_lte: ID
  id_in: [ID!]
  id_not_in: [ID!]
  cityIndex: String
  cityIndex_not: String
  cityIndex_gt: String
  cityIndex_lt: String
  cityIndex_gte: String
  cityIndex_lte: String
  cityIndex_in: [String!]
  cityIndex_not_in: [String!]
  cityIndex_contains: String
  cityIndex_contains_nocase: String
  cityIndex_not_contains: String
  cityIndex_not_contains_nocase: String
  cityIndex_starts_with: String
  cityIndex_starts_with_nocase: String
  cityIndex_not_starts_with: String
  cityIndex_not_starts_with_nocase: String
  cityIndex_ends_with: String
  cityIndex_ends_with_nocase: String
  cityIndex_not_ends_with: String
  cityIndex_not_ends_with_nocase: String
  cityIndex_: CityIndex_filter
  seller: Bytes
  seller_not: Bytes
  seller_gt: Bytes
  seller_lt: Bytes
  seller_gte: Bytes
  seller_lte: Bytes
  seller_in: [Bytes!]
  seller_not_in: [Bytes!]
  seller_contains: Bytes
  seller_not_contains: Bytes
  amount: BigInt
  amount_not: BigInt
  amount_gt: BigInt
  amount_lt: BigInt
  amount_gte: BigInt
  amount_lte: BigInt
  amount_in: [BigInt!]
  amount_not_in: [BigInt!]
  blockNumber: BigInt
  blockNumber_not: BigInt
  blockNumber_gt: BigInt
  blockNumber_lt: BigInt
  blockNumber_gte: BigInt
  blockNumber_lte: BigInt
  blockNumber_in: [BigInt!]
  blockNumber_not_in: [BigInt!]
  timestamp: BigInt
  timestamp_not: BigInt
  timestamp_gt: BigInt
  timestamp_lt: BigInt
  timestamp_gte: BigInt
  timestamp_lte: BigInt
  timestamp_in: [BigInt!]
  timestamp_not_in: [BigInt!]
  """Filter for the block changed event."""
  _change_block: BlockChangedFilter
  and: [TokenSell_filter]
  or: [TokenSell_filter]
}

enum TokenSell_orderBy {
  id
  cityIndex
  cityIndex__id
  cityIndex__owner
  cityIndex__name
  cityIndex__code
  cityIndex__symbol
  cityIndex__squareFeet
  cityIndex__createdAtBlock
  cityIndex__createdAtTimestamp
  seller
  amount
  blockNumber
  timestamp
}

type _Block_ {
  """The hash of the block"""
  hash: Bytes
  """The block number"""
  number: Int!
  """Integer representation of the timestamp stored in blocks for the chain"""
  timestamp: Int
  """The hash of the parent block"""
  parentHash: Bytes
}

"""The type for the top-level _meta field"""
type _Meta_ {
  """
  Information about a specific subgraph block. The hash of the block
  will be null if the _meta field has a block constraint that asks for
  a block number. It will be filled if the _meta field has no block constraint
  and therefore asks for the latest  block
  
  """
  block: _Block_!
  """The deployment ID"""
  deployment: String!
  """If `true`, the subgraph encountered indexing errors at some past block"""
  hasIndexingErrors: Boolean!
}

enum _SubgraphErrorPolicy_ {
  """Data will be returned even if the subgraph has indexing errors"""
  allow
  """
  If the subgraph has indexing errors, data will be omitted. The default.
  """
  deny
}